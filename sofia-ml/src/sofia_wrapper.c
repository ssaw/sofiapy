/* This file was generated by PyBindGen 0.16.0 */
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stddef.h>


#if PY_VERSION_HEX < 0x020400F0

#define PyEval_ThreadsInitialized() 1

#define Py_CLEAR(op)				\
        do {                            	\
                if (op) {			\
                        PyObject *tmp = (PyObject *)(op);	\
                        (op) = NULL;		\
                        Py_DECREF(tmp);		\
                }				\
        } while (0)


#define Py_VISIT(op)							\
        do { 								\
                if (op) {						\
                        int vret = visit((PyObject *)(op), arg);	\
                        if (vret)					\
                                return vret;				\
                }							\
        } while (0)

#endif



#if PY_VERSION_HEX < 0x020500F0

typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intobjargproc ssizeobjargproc;

#endif


#if     __GNUC__ > 2
# define PYBINDGEN_UNUSED(param) param __attribute__((__unused__))
#elif     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
# define PYBINDGEN_UNUSED(param) __attribute__((__unused__)) param
#else
# define PYBINDGEN_UNUSED(param) param
#endif  /* !__GNUC__ */

typedef enum _PyBindGenWrapperFlags {
   PYBINDGEN_WRAPPER_FLAG_NONE = 0,
   PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED = (1<<0),
} PyBindGenWrapperFlags;


#include "sf-weight-vector.h"
#include "sofia-ml-methods.h"
#include "sofia.h"
#include <string>
#include <vector>
#include <cstdlib>
/* --- forward declarations --- */


typedef struct {
    PyObject_HEAD
    SfWeightVector *obj;
    PyBindGenWrapperFlags flags:8;
} PySfWeightVector;


extern PyTypeObject PySfWeightVector_Type;


typedef struct {
    PyObject_HEAD
    SfSparseVector *obj;
    PyBindGenWrapperFlags flags:8;
} PySfSparseVector;


extern PyTypeObject PySfSparseVector_Type;


typedef struct {
    PyObject_HEAD
    SfDataSet *obj;
    PyBindGenWrapperFlags flags:8;
} PySfDataSet;


extern PyTypeObject PySfDataSet_Type;


typedef struct {
    PyObject_HEAD
    std::vector<float> *obj;
} Pystd__vector__lt__float__gt__;


typedef struct {
    PyObject_HEAD
    Pystd__vector__lt__float__gt__ *container;
    std::vector<float>::iterator *iterator;
} Pystd__vector__lt__float__gt__Iter;


extern PyTypeObject Pystd__vector__lt__float__gt___Type;
extern PyTypeObject Pystd__vector__lt__float__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___float___gt__(PyObject *arg, std::vector<float> *container);
/* --- forward declarations --- */


typedef struct {
    PyObject_HEAD
    sofia_ml::SofiaConfig *obj;
    PyBindGenWrapperFlags flags:8;
} PySofia_mlSofiaConfig;


extern PyTypeObject PySofia_mlSofiaConfig_Type;


int _wrap_convert_py2c__float(PyObject *value, float *address);

/* --- module functions --- */


PyObject *
_wrap_sofia_sofia_ml_SvmPredictionsOnTestSet(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::vector< float > retval;
    PySfDataSet *test_data;
    PySfWeightVector *w;
    const char *keywords[] = {"test_data", "w", NULL};
    Pystd__vector__lt__float__gt__ *py_std__vector__lt__float__gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PySfDataSet_Type, &test_data, &PySfWeightVector_Type, &w)) {
        return NULL;
    }
    retval = sofia_ml::SvmPredictionsOnTestSet(*((PySfDataSet *) test_data)->obj, *((PySfWeightVector *) w)->obj);
    py_std__vector__lt__float__gt__ = PyObject_New(Pystd__vector__lt__float__gt__, &Pystd__vector__lt__float__gt___Type);
    py_std__vector__lt__float__gt__->obj = new std::vector<float>(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__float__gt__);
    return py_retval;
}
PyObject * _wrap_sofia_sofia_ml_SvmPredictionsOnTestSet(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_sofia_sofia_ml_LogisticPredictionsOnTestSet(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::vector< float > retval;
    PySfDataSet *test_data;
    PySfWeightVector *w;
    const char *keywords[] = {"test_data", "w", NULL};
    Pystd__vector__lt__float__gt__ *py_std__vector__lt__float__gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PySfDataSet_Type, &test_data, &PySfWeightVector_Type, &w)) {
        return NULL;
    }
    retval = sofia_ml::LogisticPredictionsOnTestSet(*((PySfDataSet *) test_data)->obj, *((PySfWeightVector *) w)->obj);
    py_std__vector__lt__float__gt__ = PyObject_New(Pystd__vector__lt__float__gt__, &Pystd__vector__lt__float__gt___Type);
    py_std__vector__lt__float__gt__->obj = new std::vector<float>(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__float__gt__);
    return py_retval;
}
PyObject * _wrap_sofia_sofia_ml_LogisticPredictionsOnTestSet(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_sofia_sofia_ml_SvmObjective(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    float retval;
    PySfDataSet *test_data;
    PySfWeightVector *w;
    PySofia_mlSofiaConfig *config;
    const char *keywords[] = {"test_data", "w", "config", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!O!", (char **) keywords, &PySfDataSet_Type, &test_data, &PySfWeightVector_Type, &w, &PySofia_mlSofiaConfig_Type, &config)) {
        return NULL;
    }
    retval = sofia_ml::SvmObjective(*((PySfDataSet *) test_data)->obj, *((PySfWeightVector *) w)->obj, *((PySofia_mlSofiaConfig *) config)->obj);
    py_retval = Py_BuildValue((char *) "f", retval);
    return py_retval;
}
PyObject * _wrap_sofia_sofia_ml_SvmObjective(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);

static PyMethodDef sofia_sofia_ml_functions[] = {
    {(char *) "SvmPredictionsOnTestSet", (PyCFunction) _wrap_sofia_sofia_ml_SvmPredictionsOnTestSet, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "LogisticPredictionsOnTestSet", (PyCFunction) _wrap_sofia_sofia_ml_LogisticPredictionsOnTestSet, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SvmObjective", (PyCFunction) _wrap_sofia_sofia_ml_SvmObjective, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */


static PyObject* _wrap_PySofia_mlSofiaConfig__get_iterations(PySofia_mlSofiaConfig *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(self->obj->iterations));
    return py_retval;
}
static int _wrap_PySofia_mlSofiaConfig__set_iterations(PySofia_mlSofiaConfig *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &self->obj->iterations)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PySofia_mlSofiaConfig__get_dimensionality(PySofia_mlSofiaConfig *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "N", PyLong_FromUnsignedLong(self->obj->dimensionality));
    return py_retval;
}
static int _wrap_PySofia_mlSofiaConfig__set_dimensionality(PySofia_mlSofiaConfig *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "I", &self->obj->dimensionality)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PySofia_mlSofiaConfig__get_lambda_param(PySofia_mlSofiaConfig *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "f", self->obj->lambda_param);
    return py_retval;
}
static int _wrap_PySofia_mlSofiaConfig__set_lambda_param(PySofia_mlSofiaConfig *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "f", &self->obj->lambda_param)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PySofia_mlSofiaConfig__get_learner_type(PySofia_mlSofiaConfig *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "i", self->obj->learner_type);
    return py_retval;
}
static int _wrap_PySofia_mlSofiaConfig__set_learner_type(PySofia_mlSofiaConfig *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->learner_type)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PySofia_mlSofiaConfig__get_eta_type(PySofia_mlSofiaConfig *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "i", self->obj->eta_type);
    return py_retval;
}
static int _wrap_PySofia_mlSofiaConfig__set_eta_type(PySofia_mlSofiaConfig *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->eta_type)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PySofia_mlSofiaConfig__get_loop_type(PySofia_mlSofiaConfig *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "i", self->obj->loop_type);
    return py_retval;
}
static int _wrap_PySofia_mlSofiaConfig__set_loop_type(PySofia_mlSofiaConfig *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->loop_type)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PySofia_mlSofiaConfig__get_prediction_type(PySofia_mlSofiaConfig *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "i", self->obj->prediction_type);
    return py_retval;
}
static int _wrap_PySofia_mlSofiaConfig__set_prediction_type(PySofia_mlSofiaConfig *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "i", &self->obj->prediction_type)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PySofia_mlSofiaConfig__getsets[] = {
    {
        (char*) "dimensionality", /* attribute name */
        (getter) _wrap_PySofia_mlSofiaConfig__get_dimensionality, /* C function to get the attribute */
        (setter) _wrap_PySofia_mlSofiaConfig__set_dimensionality, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "prediction_type", /* attribute name */
        (getter) _wrap_PySofia_mlSofiaConfig__get_prediction_type, /* C function to get the attribute */
        (setter) _wrap_PySofia_mlSofiaConfig__set_prediction_type, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "loop_type", /* attribute name */
        (getter) _wrap_PySofia_mlSofiaConfig__get_loop_type, /* C function to get the attribute */
        (setter) _wrap_PySofia_mlSofiaConfig__set_loop_type, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "learner_type", /* attribute name */
        (getter) _wrap_PySofia_mlSofiaConfig__get_learner_type, /* C function to get the attribute */
        (setter) _wrap_PySofia_mlSofiaConfig__set_learner_type, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "lambda_param", /* attribute name */
        (getter) _wrap_PySofia_mlSofiaConfig__get_lambda_param, /* C function to get the attribute */
        (setter) _wrap_PySofia_mlSofiaConfig__set_lambda_param, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "iterations", /* attribute name */
        (getter) _wrap_PySofia_mlSofiaConfig__get_iterations, /* C function to get the attribute */
        (setter) _wrap_PySofia_mlSofiaConfig__set_iterations, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "eta_type", /* attribute name */
        (getter) _wrap_PySofia_mlSofiaConfig__get_eta_type, /* C function to get the attribute */
        (setter) _wrap_PySofia_mlSofiaConfig__set_eta_type, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PySofia_mlSofiaConfig__tp_init__0(PySofia_mlSofiaConfig *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new sofia_ml::SofiaConfig();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PySofia_mlSofiaConfig__tp_init__1(PySofia_mlSofiaConfig *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PySofia_mlSofiaConfig *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PySofia_mlSofiaConfig_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new sofia_ml::SofiaConfig(*((PySofia_mlSofiaConfig *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PySofia_mlSofiaConfig__tp_init(PySofia_mlSofiaConfig *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PySofia_mlSofiaConfig__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PySofia_mlSofiaConfig__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


static PyObject*
_wrap_PySofia_mlSofiaConfig__copy__(PySofia_mlSofiaConfig *self)
{

    PySofia_mlSofiaConfig *py_copy;
    py_copy = PyObject_New(PySofia_mlSofiaConfig, &PySofia_mlSofiaConfig_Type);
    py_copy->obj = new sofia_ml::SofiaConfig(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PySofia_mlSofiaConfig_methods[] = {
    {(char *) "__copy__", (PyCFunction) _wrap_PySofia_mlSofiaConfig__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySofia_mlSofiaConfig__tp_dealloc(PySofia_mlSofiaConfig *self)
{
        sofia_ml::SofiaConfig *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PySofia_mlSofiaConfig__tp_richcompare (PySofia_mlSofiaConfig *PYBINDGEN_UNUSED(self), PySofia_mlSofiaConfig *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PySofia_mlSofiaConfig_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PySofia_mlSofiaConfig_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "sofia.sofia_ml.SofiaConfig",            /* tp_name */
    sizeof(PySofia_mlSofiaConfig),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySofia_mlSofiaConfig__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySofia_mlSofiaConfig__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySofia_mlSofiaConfig_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PySofia_mlSofiaConfig__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySofia_mlSofiaConfig__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- enumerations --- */










static PyObject *
initsofia_sofia_ml(void)
{
    PyObject *m;
    m = Py_InitModule3((char *) "sofia.sofia_ml", sofia_sofia_ml_functions, NULL);
    if (m == NULL) {
        return NULL;
    }
    /* Register the 'sofia_ml::SofiaConfig' class */
    if (PyType_Ready(&PySofia_mlSofiaConfig_Type)) {
        return NULL;
    }
    PyModule_AddObject(m, (char *) "SofiaConfig", (PyObject *) &PySofia_mlSofiaConfig_Type);
    PyModule_AddIntConstant(m, (char *) "PEGASOS", sofia_ml::PEGASOS);
    PyModule_AddIntConstant(m, (char *) "LOGREG_PEGASOS", sofia_ml::LOGREG_PEGASOS);
    PyModule_AddIntConstant(m, (char *) "LOGREG", sofia_ml::LOGREG);
    PyModule_AddIntConstant(m, (char *) "LMS_REGRESSION", sofia_ml::LMS_REGRESSION);
    PyModule_AddIntConstant(m, (char *) "SGD_SVM", sofia_ml::SGD_SVM);
    PyModule_AddIntConstant(m, (char *) "BASIC_ETA", sofia_ml::BASIC_ETA);
    PyModule_AddIntConstant(m, (char *) "PEGASOS_ETA", sofia_ml::PEGASOS_ETA);
    PyModule_AddIntConstant(m, (char *) "CONSTANT", sofia_ml::CONSTANT);
    PyModule_AddIntConstant(m, (char *) "STOCHASTIC", sofia_ml::STOCHASTIC);
    PyModule_AddIntConstant(m, (char *) "BALANCED_STOCHASTIC", sofia_ml::BALANCED_STOCHASTIC);
    PyModule_AddIntConstant(m, (char *) "LINEAR", sofia_ml::LINEAR);
    PyModule_AddIntConstant(m, (char *) "LOGISTIC", sofia_ml::LOGISTIC);
    return m;
}
/* --- module functions --- */


PyObject *
_wrap_sofia_LoadModelFromFile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SfWeightVector *retval;
    const char *file_name;
    Py_ssize_t file_name_len;
    std::string file_name_std;
    const char *keywords[] = {"file_name", NULL};
    PySfWeightVector *py_SfWeightVector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &file_name, &file_name_len)) {
        return NULL;
    }
    file_name_std = std::string(file_name, file_name_len);
    retval = LoadModelFromFile(file_name_std);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SfWeightVector = PyObject_New(PySfWeightVector, &PySfWeightVector_Type);
    py_SfWeightVector->obj = retval;
    py_SfWeightVector->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_SfWeightVector);
    return py_retval;
}
PyObject * _wrap_sofia_LoadModelFromFile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_sofia_srand(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    unsigned int seed;
    const char *keywords[] = {"seed", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "I", (char **) keywords, &seed)) {
        return NULL;
    }
    srand(seed);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_sofia_srand(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_sofia_SaveModelToFile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *file_name;
    Py_ssize_t file_name_len;
    PySfWeightVector *w;
    SfWeightVector *w_ptr;
    const char *keywords[] = {"file_name", "w", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O!", (char **) keywords, &file_name, &file_name_len, &PySfWeightVector_Type, &w)) {
        return NULL;
    }
    w_ptr = (w ? w->obj : NULL);
    SaveModelToFile(std::string(file_name, file_name_len), w_ptr);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}
PyObject * _wrap_sofia_SaveModelToFile(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);


PyObject *
_wrap_sofia_TrainModel(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    SfWeightVector *retval;
    PySfDataSet *training_data;
    PySofia_mlSofiaConfig *config;
    const char *keywords[] = {"training_data", "config", NULL};
    PySfWeightVector *py_SfWeightVector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PySfDataSet_Type, &training_data, &PySofia_mlSofiaConfig_Type, &config)) {
        return NULL;
    }
    retval = TrainModel(*((PySfDataSet *) training_data)->obj, *((PySofia_mlSofiaConfig *) config)->obj);
    if (!(retval)) {
        Py_INCREF(Py_None);
        return Py_None;
    }
    py_SfWeightVector = PyObject_New(PySfWeightVector, &PySfWeightVector_Type);
    py_SfWeightVector->obj = retval;
    py_SfWeightVector->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_retval = Py_BuildValue((char *) "N", py_SfWeightVector);
    return py_retval;
}
PyObject * _wrap_sofia_TrainModel(PyObject * PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs);

static PyMethodDef sofia_functions[] = {
    {(char *) "LoadModelFromFile", (PyCFunction) _wrap_sofia_LoadModelFromFile, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "srand", (PyCFunction) _wrap_sofia_srand, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "SaveModelToFile", (PyCFunction) _wrap_sofia_SaveModelToFile, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "TrainModel", (PyCFunction) _wrap_sofia_TrainModel, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */



static int
_wrap_PySfWeightVector__tp_init(PySfWeightVector *self, PyObject *args, PyObject *kwargs)
{
    int dimensionality;
    const char *keywords[] = {"dimensionality", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &dimensionality)) {
        return -1;
    }
    self->obj = new SfWeightVector(dimensionality);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static PyMethodDef PySfWeightVector_methods[] = {
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySfWeightVector__tp_dealloc(PySfWeightVector *self)
{
        SfWeightVector *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PySfWeightVector__tp_richcompare (PySfWeightVector *PYBINDGEN_UNUSED(self), PySfWeightVector *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PySfWeightVector_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PySfWeightVector_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "sofia.SfWeightVector",            /* tp_name */
    sizeof(PySfWeightVector),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySfWeightVector__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySfWeightVector__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySfWeightVector_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySfWeightVector__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PySfSparseVector__tp_init__0(PySfSparseVector *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    std::vector<float> x_value;
    float y;
    const char *keywords[] = {"x", "y", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&f", (char **) keywords, _wrap_convert_py2c__std__vector__lt___float___gt__, &x_value, &y)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new SfSparseVector(x_value, y);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PySfSparseVector__tp_init__1(PySfSparseVector *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    char const *in_string;
    const char *keywords[] = {"in_string", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s", (char **) keywords, &in_string)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new SfSparseVector(in_string);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PySfSparseVector__tp_init(PySfSparseVector *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PySfSparseVector__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PySfSparseVector__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PySfSparseVector_GetY(PySfSparseVector *self)
{
    PyObject *py_retval;
    float retval;

    retval = self->obj->GetY();
    py_retval = Py_BuildValue((char *) "f", retval);
    return py_retval;
}

static PyMethodDef PySfSparseVector_methods[] = {
    {(char *) "GetY", (PyCFunction) _wrap_PySfSparseVector_GetY, METH_NOARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySfSparseVector__tp_dealloc(PySfSparseVector *self)
{
        SfSparseVector *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PySfSparseVector__tp_richcompare (PySfSparseVector *PYBINDGEN_UNUSED(self), PySfSparseVector *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PySfSparseVector_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PySfSparseVector_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "sofia.SfSparseVector",            /* tp_name */
    sizeof(PySfSparseVector),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySfSparseVector__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySfSparseVector__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySfSparseVector_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySfSparseVector__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PySfDataSet__tp_init__0(PySfDataSet *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    bool use_bias_term;
    PyObject *py_use_bias_term;
    const char *keywords[] = {"use_bias_term", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O", (char **) keywords, &py_use_bias_term)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    use_bias_term = (bool) PyObject_IsTrue(py_use_bias_term);
    self->obj = new SfDataSet(use_bias_term);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PySfDataSet__tp_init__1(PySfDataSet *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *file_name;
    Py_ssize_t file_name_len;
    std::string file_name_std;
    bool use_bias_term;
    PyObject *py_use_bias_term;
    const char *keywords[] = {"file_name", "use_bias_term", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#O", (char **) keywords, &file_name, &file_name_len, &py_use_bias_term)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    file_name_std = std::string(file_name, file_name_len);
    use_bias_term = (bool) PyObject_IsTrue(py_use_bias_term);
    self->obj = new SfDataSet(file_name_std, use_bias_term);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PySfDataSet__tp_init(PySfDataSet *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PySfDataSet__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PySfDataSet__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PySfDataSet_AddLabeledVector(PySfDataSet *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PySfSparseVector *x;
    float y;
    const char *keywords[] = {"x", "y", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!f", (char **) keywords, &PySfSparseVector_Type, &x, &y)) {
        return NULL;
    }
    self->obj->AddLabeledVector(*((PySfSparseVector *) x)->obj, y);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PySfDataSet_NumExamples(PySfDataSet *self)
{
    PyObject *py_retval;
    long int retval;

    retval = self->obj->NumExamples();
    py_retval = Py_BuildValue((char *) "l", retval);
    return py_retval;
}


PyObject *
_wrap_PySfDataSet_VectorAt(PySfDataSet *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    long int index;
    const char *keywords[] = {"index", NULL};
    PySfSparseVector *py_SfSparseVector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "l", (char **) keywords, &index)) {
        return NULL;
    }
    SfSparseVector const & retval = self->obj->VectorAt(index);
    py_SfSparseVector = PyObject_New(PySfSparseVector, &PySfSparseVector_Type);
    py_SfSparseVector->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_SfSparseVector->obj = new SfSparseVector(retval);
    py_retval = Py_BuildValue((char *) "N", py_SfSparseVector);
    return py_retval;
}

static PyMethodDef PySfDataSet_methods[] = {
    {(char *) "AddLabeledVector", (PyCFunction) _wrap_PySfDataSet_AddLabeledVector, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "NumExamples", (PyCFunction) _wrap_PySfDataSet_NumExamples, METH_NOARGS, NULL },
    {(char *) "VectorAt", (PyCFunction) _wrap_PySfDataSet_VectorAt, METH_KEYWORDS|METH_VARARGS, NULL },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PySfDataSet__tp_dealloc(PySfDataSet *self)
{
        SfDataSet *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}

static PyObject*
_wrap_PySfDataSet__tp_richcompare (PySfDataSet *PYBINDGEN_UNUSED(self), PySfDataSet *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PySfDataSet_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}

PyTypeObject PySfDataSet_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "sofia.SfDataSet",            /* tp_name */
    sizeof(PySfDataSet),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PySfDataSet__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PySfDataSet__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PySfDataSet_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PySfDataSet__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- containers --- */



static void
Pystd__vector__lt__float__gt__Iter__tp_clear(Pystd__vector__lt__float__gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt__float__gt__Iter__tp_traverse(Pystd__vector__lt__float__gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt__float__gt____tp_dealloc(Pystd__vector__lt__float__gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__float__gt__Iter__tp_dealloc(Pystd__vector__lt__float__gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    self->ob_type->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__float__gt____tp_iter(Pystd__vector__lt__float__gt__ *self)
{
    Pystd__vector__lt__float__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__float__gt__Iter, &Pystd__vector__lt__float__gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector<float>::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt__float__gt__Iter__tp_iter(Pystd__vector__lt__float__gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt__float__gt__Iter__tp_iternext(Pystd__vector__lt__float__gt__Iter *self)
{
    PyObject *py_retval;
    std::vector<float>::iterator iter;

    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_retval = Py_BuildValue((char *) "f", (*iter));
    return py_retval;
}

int _wrap_convert_py2c__float(PyObject *value, float *address)
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "f", &*address)) {
        Py_DECREF(py_retval);
        return 0;
    }
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__vector__lt___float___gt__(PyObject *arg, std::vector<float> *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt__float__gt___Type)) {
        *container = *((Pystd__vector__lt__float__gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            float item;
            if (!_wrap_convert_py2c__float(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a vecf instance, or a list of float");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt__float__gt____tp_init(Pystd__vector__lt__float__gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector<float>;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___float___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt__float__gt___Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "sofia.vecf",            /* tp_name */
    sizeof(Pystd__vector__lt__float__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt__float__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt__float__gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt__float__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__float__gt__Iter_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "sofia.vecfIter",            /* tp_name */
    sizeof(Pystd__vector__lt__float__gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt__float__gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt__float__gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt__float__gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt__float__gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt__float__gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyMODINIT_FUNC
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__ ((visibility("default")))
#endif
initsofia(void)
{
    PyObject *m;
    PyObject *submodule;
    m = Py_InitModule3((char *) "sofia", sofia_functions, NULL);
    if (m == NULL) {
        return;
    }
    /* Register the 'SfWeightVector' class */
    if (PyType_Ready(&PySfWeightVector_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SfWeightVector", (PyObject *) &PySfWeightVector_Type);
    /* Register the 'SfSparseVector' class */
    if (PyType_Ready(&PySfSparseVector_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SfSparseVector", (PyObject *) &PySfSparseVector_Type);
    /* Register the 'SfDataSet' class */
    if (PyType_Ready(&PySfDataSet_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "SfDataSet", (PyObject *) &PySfDataSet_Type);
    /* Register the 'std::vector<float>' class */
    if (PyType_Ready(&Pystd__vector__lt__float__gt___Type)) {
        return;
    }
    if (PyType_Ready(&Pystd__vector__lt__float__gt__Iter_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "vecf", (PyObject *) &Pystd__vector__lt__float__gt___Type);
    PyModule_AddObject(m, (char *) "vecfIter", (PyObject *) &Pystd__vector__lt__float__gt__Iter_Type);
    submodule = initsofia_sofia_ml();
    if (submodule == NULL) {
        return;
    }
    Py_INCREF(submodule);
    PyModule_AddObject(m, (char *) "sofia_ml", submodule);
}
